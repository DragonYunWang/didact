<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fibre-递增对比</title>
  </head>
  <body>
    <script>
      const isEvent = (name) => name.startsWith("on")
      const isAttribute = (name) =>
        !isEvent(name) && name != "children" && name != "style"
      const isNew = (prev, next) => (key) => prev[key] !== next[key]
      const isGone = (prev, next) => (key) => !(key in next)

      function updateDomProperties(dom, prevProps, nextProps) {
        // Remove event listeners
        Object.keys(prevProps)
          .filter(isEvent)
          .filter(
            (key) => !(key in nextProps) || isNew(prevProps, nextProps)(key)
          )
          .forEach((name) => {
            const eventType = name.toLowerCase().substring(2)
            dom.removeEventListener(eventType, prevProps[name])
          })

        // Remove attributes
        Object.keys(prevProps)
          .filter(isAttribute)
          .filter(isGone(prevProps, nextProps))
          .forEach((name) => {
            dom[name] = null
          })

        // Set attributes
        Object.keys(nextProps)
          .filter(isAttribute)
          .filter(isNew(prevProps, nextProps))
          .forEach((name) => {
            dom[name] = nextProps[name]
          })

        // Set style
        prevProps.style = prevProps.style || {}
        nextProps.style = nextProps.style || {}
        Object.keys(nextProps.style)
          .filter(isNew(prevProps.style, nextProps.style))
          .forEach((key) => {
            dom.style[key] = nextProps.style[key]
          })
        Object.keys(prevProps.style)
          .filter(isGone(prevProps.style, nextProps.style))
          .forEach((key) => {
            dom.style[key] = ""
          })

        // Add event listeners
        Object.keys(nextProps)
          .filter(isEvent)
          .filter(isNew(prevProps, nextProps))
          .forEach((name) => {
            const eventType = name.toLowerCase().substring(2)
            dom.addEventListener(eventType, nextProps[name])
          })
      }

      function createDomElement(fiber) {
        const isTextElement = fiber.type === TEXT_ELEMENT
        const dom = isTextElement
          ? document.createTextNode("")
          : document.createElement(fiber.type)
        updateDomProperties(dom, [], fiber.props)
        return dom
      }
      const ENOUGH_TIME = 1 // 毫秒
      let workQueue = []
      let nextUnitOfWork = null // 全局变量, 那么一次只能走一个回调

      function schedule(task) {
        workQueue.push(task)
        window.requestIdleCallback(performWork)
      }

      function performWork(deadline) {
        workLoop(deadline)

        if (nextUnitOfWork || updateQueue.length > 0) {
          window.requestIdleCallback(performWork)
        }
      }

      function workLoop(deadline) {
        if (!nextUnitOfWork) {
          resetNextUnitWork()
        }

        while (nextUnitOfWork && deadline.timeRemaining() > ENOUGH_TIME) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
        }

        if (pendingCommit) {
          commitAllWork(pendingCommit)
        }
      }

      function resetNextUnitWork() {
        const update = updateQueue.shift()

        if (!update) {
          return
        }

        if (update.partialState) {
          update.instance.__fiber.partialState = update.partialState
        }

        const root =
          update.from === HOST_ROOT
            ? update.dom._rootContainerFiber
            : getRoot(update.instance.__fiber)

        nextUnitOfWork = {
          tag: HOST_ROOT,
          stateNode: update.dom || root.stateNode,
          props: update.newProps || root.props,
          alternate: root,
        }
      }

      function getRoot(fiber) {
        let node = fiber

        while (node.parent) {
          node = node.parent
        }

        return
      }

      function performUnitOfWork(wipFiber) {
        beginWork(wipFiber)
        if (wipFiber.child) {
          // 工作没有完成, 返回下一次更新的状态
          return wipFiber.child
        }

        let uow = wipFiber
        while (uow) {
          completeWork(uow)
          if (uow.sibling) {
            return uow.sibling
          }
          uow = uow.parent
        }
      }

      function beginWork(wipFiber) {
        if (wipFiber.tag === CLASS_COMPONENT) {
          updateClassComponent(wipFiber)
        } else {
          updateHostComponent(wipFiber)
        }
      }

      function updateHostComponent(wipFiber) {
        if (!wipFiber.stateNode) {
          wipFiber.stateNode = createInstance(wipFiber)
        }

        const newChildElements = wipFiber.props.children
        reconcileChildrenArray(wipFiber, newChildElements)
      }

      function updateClassComponent(wipFiber) {
        let instance = wipFiber.stateNode
        if (instance == null) {
          // 调用累初始化
          instance = wipFiber.stateNode = createInstance(wipFiber)
        } else if (
          wipFiber.props === instance.props &&
          !wipFiber.partialState
        ) {
          // 不需要更新, 最后复制孩子
          cloneChildFibers(wipFiber)
          return
        }
        instance.props = wipFiber.props
        instance.state = Object.assign(
          {},
          instance.state,
          wipFiber.partialState
        )
        wipFiber.partialState = null

        const newChildElements = wipFiber.stateNode.render()
        reconcileChildrenArray(wipFiber, newChildElements)
      }

      function arrify(val) {
        return val == null ? [] : Array.isArray(val) ? val : [val]
      }

      class Component {
        constructor(props) {
          this.props = {}
          this.state = this.state || {}
        }

        setState(partialState) {
          scheduleUpdate(this, partialState)
        }
      }

      function createInstance(fiber) {
        const instance = new fiber.type(fiber.props)
        instance.__fiber = fiber
        return instance
      }

      // Fiber tags
      const HOST_COMPONENT = "host"
      const CLASS_COMPONENT = "class"
      const HOST_ROOT = "ROOT"

      const updateQueue = []
      let pendingCommit = null

      function render(elements, containerDom) {
        updateQueue.push({
          from: HOST_ROOT,
          dom: containerDom,
          newProps: { children: elements },
        })

        requestIdleCallback(performWork)
      }

      function scheduleUpdate(instance, partialState) {
        updateQueue.push({
          from: CLASS_COMPONENT,
          instance: instance,
          partialState: partialState,
        })

        requestIdleCallback(performWork)
      }
    </script>
  </body>
</html>
